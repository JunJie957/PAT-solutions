/*
	题目描述：

		1005 继续(3n+1)猜想 (25分)

		卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。

		当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。
		例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，
		而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。
		我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。

		现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，
		就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，
		并按从大到小的顺序输出它们。

		输入格式：
		
		每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (<100)，
		第 2 行给出 K 个互不相同的待验证的正整数 n (1<n≤100)的值，数字间用空格隔开。

		输出格式：
		每个测试用例的输出占一行，按从大到小的顺序输出关键数字。
		数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。

		输入样例：
		6
		3 5 6 7 8 11

		输出样例：
		7 6
*/

/*
	题目分析：

		(1) 题目要求输出所有的"关键数"，即在计算过程中，没有被覆盖到的数字。
		
		(2) 先将所有的数字输入，因为数字的区间为[2,100]，所以建立一个数组，当某个数字输入，
		    将此数字作为下标，将数组元素置为true。
		
		(3) 数字输入完毕后，从大到小对所有的数字进行计算，数字越大，在计算过程中覆盖的数也就越多，
			因此，从大到小计算。在计算的过程中，去判断计算所产生的数字是否在输入的数组中，如果存在，
			则将此数字置为is_not_key，因为它被“覆盖”了。
		
		(4) 将所有的数字计算完成后，从小到大进行输出。输出所有为key的数字(即is_not_key == false)。 
*/

/*
	代码实现
*/

#include <iostream>
using namespace std;

struct judge
{
	bool is_num;
	bool is_not_key;
};

int main()
{
	// 输入行数
	int k;
	cin >> k;

	// 判断数组初始化
	judge arr[101];
	for (int i = 0; i <= 100; ++i)
	{
		arr[i].is_num = false;
		arr[i].is_not_key = false;
	}

	// 输入k个数
	int num;
	for (int i = 0; i < k; ++i)
	{
		cin >> num;
		arr[num].is_num = true;
	}

	// 依次对k个数进行判断
	int tmp;
	for (int i = 2; i < 101; ++i)
	{
		tmp = i;
		if (arr[tmp].is_num == true && arr[tmp].is_not_key == false)
		{
			while (tmp != 1)
			{
				if (tmp % 2 == 0) tmp /= 2;
				else if (tmp % 2 != 0) tmp = (tmp * 3 + 1) / 2;
				if(arr[tmp].is_num == true && tmp <= 100) arr[tmp].is_not_key = true;
			}
		}
	}

	// 依照格式输出
	bool first = false;
	for (int i = 100; i > 1; --i)
	{
		if (arr[i].is_num == true && arr[i].is_not_key == false)
		{
			if (first == false)
			{
				first = true;
				cout << i;
			}
			else
			{
				cout << " " << i;
			} 
		}
	}
	return 0;
}
